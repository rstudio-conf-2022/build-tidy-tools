---
title: "ðŸ“¦ <br>Building tidy tools"
subtitle: "Day 2 Session 1: Function Design"
author: "Emma Rand and Ian Lyttle"
date: "<br>ðŸ”— [bit.ly/...](https://bit.ly/..)"
format:
  revealjs: 
    theme: [simple, emma.scss]
    slide-number: true
    chalkboard: true
    preview-links: auto
    footer: <https://bit.ly/..>
    margin: 0.07
    code-link: true
    code-line-numbers: false
execute:
  echo: true
  eval: false
bibliography: references.bib
---

# ðŸ‘‹ Welcome Back

## The Team

::: columns
::: {.column width="50%"}
Emma Rand ðŸ¦[er13_r](https://twitter.com/er13_r?lang=en)

Elliot Murphy

Beatriz Milz
:::

::: {.column width="50%"}
Ian Lyttle ðŸ¦[ijlyttle](https://twitter.com/ijlyttle?lang=en)

Haley Jeppson

Ted Laderas
:::
:::

Standing on the shoulders of Building Tidy Tools, rstudio::conf(2020) [@wickham2021a], R Packages [@wickham2020]

## Code of conduct

## Housekeeping

-   Toilets

-   Fire exits and alarms

-   anything else?

## How we will work

-   stickies

-   no stupid questions

## Schedule

 - Function design
 
 - Working with side effects
 
 - Tidy Eval
 
 - Miscellany

## State of play

We want to *concentrate on specific concepts*, rather than writing entire functions.

We have created a set of checkpoints called **states**:

```{r eval=TRUE}
btt22::btt_state()
```

For example, `"2.1.1"` means day **2**, session **1**, task **1**.

## Getting new files

To get *new* files for a state:

```r
# "2.1.1": day 2, session 1, task 1
btt_get("2.1.1")
```

. . . 

- files to directories `R`, `tests/testthat`.
- contains functions, tests that *you* will complete.

## Staying on the "happy path"

One example builds on another, so it's important to keep up.

. . . 

We will do our best to help; in case you need to reset:

```r
btt_reset_hard("2.1.1")
```

. . .

Overwrites:

- directories: `R`, `tests/testthat`
- `Imports`, `Suggests` sections of `DESCRIPTION` 

. . .

## Learning objectives 

At the end of this section you will be able to:
 
 - order and name your function's arguments.
 - recognize type-stable functions and their importance.
 - distinguish a pure function from a function that has or uses side effects.

But first...
 
## Make R CMD CHECK happy {.smaller}

When we finished yesterday:
 
```default
> checking R code for possible problems ... NOTE
  uss_make_matches: no visible binding for global variable â€˜tierâ€™
  uss_make_matches: no visible binding for global variable â€˜Seasonâ€™
  uss_make_matches: no visible binding for global variable â€˜Dateâ€™
  uss_make_matches: no visible binding for global variable â€˜homeâ€™
  uss_make_matches: no visible binding for global variable â€˜visitorâ€™
  uss_make_matches: no visible binding for global variable â€˜hgoalâ€™
  uss_make_matches: no visible binding for global variable â€˜vgoalâ€™
  Undefined global functions or variables:
    Date Season hgoal home tier vgoal visitor

0 errors âœ“ | 0 warnings âœ“ | 1 note x
``` 

. . .

Where does `tier`, etc. come from?

. . . 

- We know it's a column in a data frame, but R doesn't know that.

- How to specify "this comes from a data frame" ? 

## Preview of tidy eval

The {rlang} package provides pronouns.

. . . 

Interactively, we might write:

```r
mtcars |>
  mutate(cons_lper100km = 235.215 / mpg)
```

. . .

In a package function, we would write:

```r
mtcars |>
  dplyr::mutate(cons_lper100km = 235.215 / .data$mpg)
```

## Your turn `"2.1.1"`

1. Add the {rlang} package:

```r
usethis::use_package("rlang")
```

2. Import the `.data` pronoun:

```r
# adds to R/ussie-package.R
usethis::use_import_from("rlang", ".data")
```

3. `R/matches.R`: use `.data` in `uss_make_matches()`.

4. `devtools::check()`, should be happy now.

## API design

. . .

A thing I like about tidyverse: 

. . .

 - *there should be a function to do* **this**; *it should look like* **this** 
 
 . . .
  
 - there already is
 
 . . . 
 
 Because:
 
  - functions and arguments follow naming conventions
 
  - arguments are ordered according to purpose
 
  - we know what to expect for return values

## Evolving references

The way we approach problems is always evolving; tidyverse is no exception:

. . .

- [Tidyverse Style Guide](https://style.tidyverse.org/){preview-link="true"}

. . .

- [Tidyverse Design Guide](https://design.tidyverse.org/){preview-link="true"}

. . .

- follow the GitHub repo of your favorite tidyverse/r-lib package (mine is {usethis}):
  - issue discussions
  - pull-request reviews

## Naming functions

If writing a smaller package, consider prefixing your functions:

 - {ussie}: `uss_make_matches()`
 
 - {btt22}: `btt_get()`

. . .

Use a *verb* next:

 - `dplyr::mutate()`, `stringr::str_split()`

. . . 

Use a *noun* if building up a specific type of object:

 - `ggplot2::ggplot()`, `ggplot2::geom_point()`

## Casing

- Tidyverse uses `snake_case`

- Python prefers `snake_case`

- JavaScript prefers:
  - `camelCase` for functions 
  - `PascalCase` for classes, interfaces

. . . 

Pick a convention according to your domain, follow it.

## Arguments

Here, `mtcars` is an *argument*:

```r
head(mtcars)
```

. . . 

Here, `data` is a *formal argument*:

```r
head <- function(data){
  ...
}
```

. . .

In R, we sometimes use these terms interchangeably; we sometimes use the term *formals*. 

. . .

`Â¯\_(ãƒ„)_/Â¯`

## Naming arguments

Like naming functions, strive to be:

- consistent
- evocative
- concise

. . .

> There are only two hard things in Computer Science: cache invalidation and naming things.
>
> -- Phil Karlton

. . .

> And off-by-one errors -- [Leon Bambrick](https://twitter.com/secretGeek/status/7269997868)

## Ordering arguments

- **data**: first argument, "the thing" 
- **descriptors**: values the user should specify
- **dots** (`...`): stuff that gets passed to other functions
- **details**: values with defaults

. . . 

I have seen the order of **dots** and **details** reversed.

However, **data** and **descriptors** almost always come first.

## Discuss with neighbor

Which are: data, descriptors, details?

```r
# there are acutally more args...
pivot_longer <- function(
  data,                
  cols,                
  names_to = "name",   
  names_prefix = NULL  
) {
  ...
}
```

## Discuss with neighbor (answer)

Which are: data, descriptors, details?

```r
# there are acutally more args...
pivot_longer <- function(
  data,                # data
  cols,                # descriptor
  names_to = "name",   # details
  names_prefix = NULL  #
) {
  ...
}
```

## Return value: type stability


## Putting it all together

When I think of tidyverse functions, I can remember type for:

- first argument

- return value

. . .

For example:

- `dplyr::mutate()`: tibble -> tibble

- `tidyr::pivot_longer()`: tibble -> tibble

. . .

tibble -> tibble pattern makes it easy to work with the pipe: `|>`  



## Make a function
 
## Pure functions vs. side effects

## References {.smaller}

