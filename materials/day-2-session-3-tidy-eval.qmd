---
title: "ðŸ“¦ <br>Building tidy tools"
subtitle: "Day 2 Session 3: Tidy Eval"
author: "Emma Rand and Ian Lyttle"
date: "<br>ðŸ”— [bit.ly/...](https://bit.ly/..)"
format:
  revealjs: 
    theme: [simple, emma.scss]
    slide-number: true
    chalkboard: true
    preview-links: auto
    footer: <https://bit.ly/..>
    margin: 0.07
    code-link: true
    code-line-numbers: false
execute:
  echo: true
  eval: false
bibliography: references.bib
---

## Learning objectives 

At the end of this section you will be able to:

- build functions that call tidyverse functions, using *bare-name* arguments:
  - designed for interactive use, i.e. like `dplyr::filter()` 
- understand terms: data masking, tidy select, dynamic dots
- recognize other ways to use tidy eval:
  - functions that call tidyverse functions using *string-based* arguments, i.e. for use with Shiny.
  - correspondence with techniques used for *bare-name* arguments.

## Motivation for tidy eval

Tidy eval (and non-standard evaluation generally in R) exists so that we can refer to data columns using bare names.

```r
dplyr::filter(mtcars, cyl == 4)
```

. . .

```python
# python, using pandas
mtcars.query('cyl == 4')
```

. . . 

 - It makes things easier if you are working interactively.
 - It makes things more interesting if you are writing functions. 

. . . 
 
Welcome to *more interesting*.

## Families of tidy-eval arguments

There are two families of tidy-eval arguments:

. . .

 - **data-masking**: evaluate variables in context of data frame
 
    ```r
    mtcars |>
      dplyr::mutate(wt_kg = wt * 1000 / 2.2)
    ```
    
. . . 

 - **tidy-select**: specify columns within a data frame
 
   ```r
   mtcars |>
     dplyr:select(starts_with("w"))
   ```
   
## Ways to express tidy-eval 

. . .

 - using bare names, what we do in interactive programming:
 
    ```r
    mtcars |>
      dplyr::mutate(wt_kg = wt * 1000 / 2.2)
    ```

. . .

  - using strings, useful for Shiny :
  
    ```r
    mtcars |>
      dplyr::mutate("wt_kg" := .data[["wt"]] * 1000 / 2.2)
    ```

. . .

Here, we focus mostly on interactive programming.

## Goal

Write functions that:

 - call tidyverse functions, e.g. `dplyr::filter()`
 - "look and feel" like tidyverse functions:
   - your users can call using bare names

. . . 

Out of scope:

 - underlying theory of quasiquotation, i.e. `rlang::quo()`, `rlang::enquo()`, `rlang::eval_tidy()` 

## Pass the dots

This is the simplest possible solution. 

. . .

 - If the tidyverse function you're using takes `...` as an argument,

. . .

 - and that's what you want to pass along, 

. . . 
 
then you can **pass the dots**.

```r
my_select <- function(.data, ...) {
  dplyr::select(.data, ...)
}
```

## Your turn `"2.3.1"`



. . .

<hr>
**Only** *if needed*, `btt22::btt_reset_hard("2.3.1")`
<hr>

. . . 

*No* new files.

. . .

## Pass the dots to `filter()` results

In `uss_get_matches()`:

- Add `...` to the formal arguments.

- Pass the dots to `dplyr::filter()`.

- Document: 

  - use `#' @inheritParams dplyr::filter` 
  - add example
  - add to package vignette

- Add test (`usethis::use_test()`)

- `devtools::check()`

## Pronouns: `.data`, `.env`

```r
dplyr::filter(mtcars, cyl == 4) |> nrow()
```
. . .

```
[1] 11
```

<hr>

. . .

```r
cyl <- 4
dplyr::filter(mtcars, cyl == cyl) |> nrow()
```
. . .

```
[1] 32
```

<hr>

. . .

```r
library("rlang")
cyl <- 4
dplyr::filter(mtcars, .data$cyl == .env$cyl) |> nrow()
```

. . .

```
[1] 11
```

## Pronouns

The `.data` and `.env` pronouns are provided by {rlang}.

. . . 

For *data-masking* functions, make explicit how to evaluate variables.

. . .

To use them in your package:

```r
# we have .data already
usethis::use_import_from("rlang", c(".data", ".env"))
```

## Your turn `"2.3.2"`

. . .

<hr>
**Only** *if needed*, `btt22::btt_reset_hard("2.3.2")`
<hr>

. . . 
 
Get new files, `btt22::btt_get("2.3.2")`:

 - `teams-matches.R`
 - `test-teams-matches.R`

Go through what code does.

. . .

If you have not already:

`usethis::use_import_from("rlang", ".env")`

## Use `.env` pronoun

```r
at_home <- FALSE

teams_matches_visitor <-
  data_matches |>
  dplyr::rename(
    team = "visitor",
    opponent = "home",
    goals_against = "goals_home",
    goals_for = "goals_visitor"
  ) |>
  dplyr::mutate(at_home = FALSE)
```

- instead of `FALSE`, use `.env$at_home`.

- `devtools::check()`.

## Splicing: `!!!`

Used to splice a list or vector into a `...` argument.

. . .

If you know JavaScript, it's like the destructuring operator.

. . .

It works only with [*dynamic dots*](https://rlang.r-lib.org/reference/dyn-dots.html) (a tidyverse construct).

. . . 

```r
mtcars |>
  dplyr::rename(mpg = "new_mpg", cyl = "new_cyl")
```

. . .

```r
new_names <- c(mpg = "new_mpg", cyl = "new_cyl")

mtcars |>
  dplyr::rename(!!!new_names)
```

. . .

Remember:`!!!` reflects `...`


## Your turn `"2.3.3"`

. . .

<hr>
**Only** *if needed*, `btt22::btt_reset_hard("2.3.3")`
<hr>

. . . 

*No* new files.

## Splice renaming

```r
teams_matches_home <-
  data_matches |>
  dplyr::rename(
    team = "home",
    opponent = "visitor",
    goals_for = "goals_home",
    goals_against = "goals_visitor"
  ) |>
  dplyr::mutate(at_home = TRUE)
```

- look at `rename_home()` and `rename_visitor()`.

- Use `!!!` with `teams_matches_home()`, `_visitor()`.

- `devtools::check()`.

## New columns

With [*dynamic dots*](https://rlang.r-lib.org/reference/dyn-dots.html) you can name new columns using variables.

. . .

```r
prefix <- "new"

mtcars |>
  dplyr::rename("{prefix}_mpg" := .data$mpg)
```

. . .

Two things to keep in mind:

- left side of expression is a {glue}-enabled string.
- operator is `:=`, not `=`. 

. . . 

To use in your package:

```r
usethis::use_import_from("rlang", ":=")
```

## Your turn `"2.3.4"`

. . .

<hr>
**Only** *if needed*, `btt22::btt_reset_hard("2.3.4")`
<hr>

. . . 

*No* new files.

## Naming columns

```r
name_of_at_home <- "at_home"

teams_matches_visitor <-
  data_matches |>
  dplyr::rename(!!!rename_visitor()) |>
  dplyr::mutate(at_home = FALSE)
```

- use `name_of_at_home` to name column in `mutate()`

- `devtools::check()`

Remember:

- left side of expression is a {glue}-enabled string
- operator is `:=`, not `=`

## `dplyr::across()`: super useful 

- used inside *data-masking* verbs, e.g. `summarise()`

- specify:

  - which columns to consider, using *tidy-select*
  
  - what function(s), if any, to apply

. . .

```r
mtcars |>
  dplyr::group_by(dplyr::across("cyl")) |>
  dplyr::summarise(
    dplyr::across(c("mpg", "disp"), mean)
  )
```

## Our turn `"2.3.5"`

. . .

<hr>
**Only** *if needed*, `btt22::btt_reset_hard("2.3.5")`
<hr>

. . . 

*No* new files.


## `uss_make_teams_matches()`

Let's add some code near the end to arrange the rows:

```r
result <-
  teams_matches_home |>
  dplyr::bind_rows(teams_matches_visitor) |>
  dplyr::select(dplyr::all_of(cols_teams_matches())) |>
  dplyr::arrange(
    dplyr::across(
      dplyr::all_of(
        c("country", "tier", "season", "team", "date")
      )
    )
  )
```

## Accepting new snapshot

- `devtools::test()` changes the snapshot test

. . .

- `snapshot_review('teams-matches')`

. . .

::: {layout="[[1,1]]"}
![](images/snapshot-matches.png){fig-alt="Accepting change to snapshot test"}

- accept the change

- `devtools::check()`
:::

## Your turn `"2.3.6"`

. . .

<hr>
**Only** *if needed*, `btt22::btt_reset_hard("2.3.6")`
<hr>

. . . 
 
Get new files, `btt22::btt_get("2.3.6")`:

- `points.R`
- `seasons.R`
- `test-points.R`
- `test-seasons.R`

Go through what code does.

## `uss_make_seasons_final()`

- same args as `uss_make_seasons_cumulative()`
  ```r
  #' @rdname uss_make_seasons_cumulative
  #' @export
  ```
- same validation, test by uncommenting
- use `dplyr::summarise()`, vs. `dplyr::mutate()`
- `sum` quantities, rather than `cumsum`
- `summarise()` the `date` differently 
- add example, add to vignette
- `devtools::check()`

## Curly-curly: `{{}}`

## Summary

## References
